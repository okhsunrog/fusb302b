device Device {
    default-byte-order BE
    register-address-type u8
    buffer-address-type u8
    defmt-feature defmt
    /// Device Identification Register. Contains Version, Product, and Revision IDs.
    register DeviceId {
        access RO
        address 1
        fields size_bits=8 {
            /// Device Version ID. Corresponds to major hardware revisions. See Table 17.
            (uint:Fusb302Version)version_id @7:4 {
                /// Version A Hardware
                VersionA 8
                /// Version B Hardware
                VersionB 9
                /// Version C Hardware
                VersionC 10
                /// An unknown or future hardware version.
                UnknownOrFutureVersion catch-all
            }
            /// Product ID, distinguishing different FUSB302B variants/packages. See Table 17.
            (uint:Fusb302Product)product_id @3:2 {
                /// FUSB302BMPX/FUSB302BVMPX(Default) & FUSB302BUCX
                DefaultUcWlcsp 0
                /// FUSB302B01MPX (MLP only)
                Mlp01 1
                /// FUSB302B10MPX (MLP only)
                Mlp10 2
                /// FUSB302B11MPX (MLP only)
                Mlp11 3
            }
            /// Revision ID, indicating minor revision for the given hardware Version. See Table 17.
            (uint:Fusb302Revision)revision_id @1:0 {
                /// Revision A
                RevA 0
                /// Revision B
                RevB 1
                /// Revision C
                RevC 2
                /// Revision D
                RevD 3
            }
        }
    }
    /// Switch Control Register 0
    register Switches0 {
        address 2
        reset-value 3
        fields size_bits=8 {
            /// Pull-up enable for CC2 (true: apply host pull-up current).
            (bool)pu_en2 @7
            /// Pull-up enable for CC1 (true: apply host pull-up current).
            (bool)pu_en1 @6
            /// VCONN enable for CC2 (true: turn on VCONN current).
            (bool)vconn_cc2 @5
            /// VCONN enable for CC1 (true: turn on VCONN current).
            (bool)vconn_cc1 @4
            /// Measure CC2 (true: monitor/measure voltage on CC2).
            (bool)meas_cc2 @3
            /// Measure CC1 (true: monitor/measure voltage on CC1).
            (bool)meas_cc1 @2
            /// Pull-down for CC2 (true: device pull-down on).
            (bool)pdwn2 @1
            /// Pull-down for CC1 (true: device pull-down on).
            (bool)pdwn1 @0
        }
    }
    /// Switch Control Register 1
    register Switches1 {
        address 3
        reset-value 32
        fields size_bits=8 {
            /// Power role for GoodCRC packet.
            (uint:PowerRolePort)powerrole @7 {
                /// Sink for SOP
                Sink 0
                /// Source for SOP
                Source 1
            }
            /// Specification revision for GoodCRC packet.
            (uint:SpecRev?)specrev @6:5 {
                /// Revision 1.0
                Revision1_0 0
                /// Revision 2.0
                Revision2_0 1
            }
            /// Data role for GoodCRC packet (true: SRC, false: SNK for SOP).
            (bool)datarole @4
            /// Automatic CRC handling (true: auto-send GoodCRC on valid packet).
            (bool)auto_crc @2
            /// Transmit on CC2 (true: enable BMC transmit driver).
            (bool)txcc2 @1
            /// Transmit on CC1 (true: enable BMC transmit driver).
            (bool)txcc1 @0
        }
    }
    /// Measure Control Register. Used to configure MDAC for CC or VBUS measurements.
    register Measure {
        address 4
        reset-value 49
        fields size_bits=8 {
            /// Selects MDAC/comparator target. true: Measure VBUS (MEAS_CC* in Switches0 must be 0), false: Measure CC (selected by MEAS_CC*).
            (bool)meas_vbus @6
            /// Measure Block DAC data input (6-bit value). LSB is ~42mV if meas_vbus=false (CC measurement), or ~420mV if meas_vbus=true (VBUS measurement).
            (uint)mdac @5:0
        }
    }
    /// Slice Control Register
    register Slice {
        address 5
        reset-value 96
        fields size_bits=8 {
            /// SDAC hysteresis setting.
            (uint:SlicerHysteresis)sdac_hys @7:6 {
                /// No hysteresis
                NoHysteresis 0
                /// 85mV hysteresis
                Hys85mV 1
                /// 170mV hysteresis
                Hys170mV 2
                /// 255mV hysteresis
                Hys255mV 3
            }
            /// SDAC setting for BMC slicer DAC threshold.
            (uint)sdac @5:0
        }
    }
    /// Control Register 0
    register Control0 {
        address 6
        reset-value 36
        fields size_bits=8 {
            /// Flush transmit FIFO. Write true to trigger; self-clearing.
            (bool)tx_flush WO @6
            /// Interrupt mask (true: mask all interrupts).
            (bool)int_mask @5
            /// Host current setting for pull-ups.
            (uint:HostCurrent)host_cur @3:2 {
                /// No current
                NoCurrent 0
                /// 80µA - Default USB power
                Default80uA 1
                /// 180µA - 1.5A
                Medium180uA 2
                /// 330µA - 3A
                High330uA 3
            }
            /// Auto preamble (true: auto-start transmitter on good CRC).
            (bool)auto_pre @1
            /// Start transmission. Write true to trigger; self-clearing.
            (bool)tx_start WO @0
        }
    }
    /// Control Register 1
    register Control1 {
        address 7
        reset-value 0
        fields size_bits=8 {
            /// Enable SOP'' Debug packets (true: enabled).
            (bool)ensop2db @6
            /// Enable SOP' Debug packets (true: enabled).
            (bool)ensop1db @5
            /// BIST Mode 01s pattern (true: enabled for testing).
            (bool)bist_mode2 @4
            /// Flush receive FIFO. Write true to trigger; self-clearing.
            (bool)rx_flush WO @2
            /// Enable SOP'' packets (true: enabled).
            (bool)ensop2 @1
            /// Enable SOP' packets (true: enabled).
            (bool)ensop1 @0
        }
    }
    /// Control Register 2
    register Control2 {
        address 8
        reset-value 2
        fields size_bits=8 {
            /// Toggle save power setting.
            (uint:TogSavePwr)tog_save_pwr @7:6 {
                /// No disable state
                NoDisable 0
                /// Wait 40ms between cycles
                Wait40ms 1
                /// Wait 80ms between cycles
                Wait80ms 2
                /// Wait 160ms between cycles
                Wait160ms 3
            }
            /// Toggle Rd only (true: stop on Rd only).
            (bool)tog_rd_only @5
            /// Wake detection enable (true: enabled).
            (bool)wake_en @3
            /// Toggle mode selection.
            (uint:ToggleMode?)mode @2:1 {
                /// DRP polling
                DrpPolling 1
                /// SNK polling
                SnkPolling 2
                /// SRC polling
                SrcPolling 3
            }
            /// Enable toggle (true: autonomous DRP/SNK/SRC toggle).
            (bool)toggle @0
        }
    }
    /// Control Register 3
    register Control3 {
        address 9
        reset-value 6
        fields size_bits=8 {
            /// Send hard reset. Write true to initiate; self-clearing.
            (bool)send_hard_reset WO @6
            /// BIST test mode (true: clear RxFIFO after GoodCRC).
            (bool)bist_tmode @5
            /// Auto hard reset on soft reset fail (true: enabled).
            (bool)auto_hardreset @4
            /// Auto soft reset on retries fail (true: enabled).
            (bool)auto_softreset @3
            /// Number of packet retries.
            (uint:RetryCount)n_retries @2:1 {
                /// No retries
                NoRetries 0
                /// 1 retry
                OneRetry 1
                /// 2 retries
                TwoRetries 2
                /// 3 retries
                ThreeRetries 3
            }
            /// Auto retry on no GoodCRC (true: enabled).
            (bool)auto_retry @0
        }
    }
    /// Interrupt Mask Register
    register Mask {
        address 10
        reset-value 0
        fields size_bits=8 {
            /// Mask I_VBUSOK interrupt (true: masked).
            (bool)m_vbusok @7
            /// Mask I_ACTIVITY interrupt (true: masked).
            (bool)m_activity @6
            /// Mask I_COMP_CHNG interrupt (true: masked).
            (bool)m_comp_chng @5
            /// Mask I_CRC_CHK interrupt (true: masked).
            (bool)m_crc_chk @4
            /// Mask I_ALERT interrupt (true: masked).
            (bool)m_alert @3
            /// Mask I_WAKE interrupt (true: masked).
            (bool)m_wake @2
            /// Mask I_COLLISION interrupt (true: masked).
            (bool)m_collision @1
            /// Mask I_BC_LVL interrupt (true: masked).
            (bool)m_bc_lvl @0
        }
    }
    /// Power Control Register
    register Power {
        address 11
        reset-value 1
        fields size_bits=8 {
            /// Enable internal oscillator (PWR[3]).
            (bool)pwr3_internal_oscillator_enable @3
            /// Measure block powered (PWR[2]).
            (bool)pwr2_measure_block_power_enable @2
            /// Receiver powered and current references for Measure block (PWR[1]).
            (bool)pwr1_receiver_and_measure_refs_enable @1
            /// Bandgap and wake circuit enabled (PWR[0]).
            (bool)pwr0_bandgap_and_wake_enable @0
        }
    }
    /// Reset Control Register
    register Reset {
        access WO
        address 12
        fields size_bits=8 {
            /// Reset PD logic. Write true to reset; self-clearing.
            (bool)pd_reset @1
            /// Software reset. Write true to reset entire device; self-clearing.
            (bool)sw_res @0
        }
    }
    /// Over-Current Protection Register
    register Ocpreg {
        address 13
        reset-value 15
        fields size_bits=8 {
            /// OCP range (true: 100-800mA, false: 10-80mA).
            (bool)ocp_range @3
            /// OCP current setting (fraction of max range).
            (uint)ocp_cur @2:0
        }
    }
    /// Interrupt Mask Register A
    register Maska {
        address 14
        reset-value 0
        fields size_bits=8 {
            /// Mask I_OCP_TEMP interrupt (true: masked).
            (bool)m_ocp_temp @7
            /// Mask I_TOGDONE interrupt (true: masked).
            (bool)m_togdone @6
            /// Mask I_SOFTFAIL interrupt (true: masked).
            (bool)m_softfail @5
            /// Mask I_RETRYFAIL interrupt (true: masked).
            (bool)m_retryfail @4
            /// Mask I_HARDSENT interrupt (true: masked).
            (bool)m_hardsent @3
            /// Mask I_TXSENT interrupt (true: masked).
            (bool)m_txsent @2
            /// Mask I_SOFTRST interrupt (true: masked).
            (bool)m_softrst @1
            /// Mask I_HARDRST interrupt (true: masked).
            (bool)m_hardrst @0
        }
    }
    /// Interrupt Mask Register B
    register Maskb {
        address 15
        reset-value 0
        fields size_bits=8 {
            /// Mask I_GCRCSENT interrupt (true: masked).
            (bool)m_gcrcsent @0
        }
    }
    /// Control Register 4
    register Control4 {
        address 16
        reset-value 0
        fields size_bits=8 {
            /// Toggle exit on audio accessory (true: stop on Ra both CC).
            (bool)tog_exit_aud @0
        }
    }
    /// Status Register 0A
    register Status0a {
        access RO
        address 60
        fields size_bits=8 {
            /// Soft reset retries failed (true: failed).
            (bool)softfail @5
            /// Packet retries failed (true: failed).
            (bool)retryfail @4
            /// Internal power state bits (POWER3, POWER2).
            (uint)power @3:2
            /// Soft reset packet received (true: received).
            (bool)softrst @1
            /// Hard reset received (true: received).
            (bool)hardrst @0
        }
    }
    /// Status Register 1A
    register Status1a {
        access RO
        address 61
        fields size_bits=8 {
            /// Toggle state status.
            (uint:ToggleState?)togss @5:3 {
                /// Toggle logic running
                Running 0
                /// Settled to SRC on CC1
                SrcCC1 1
                /// Settled to SRC on CC2
                SrcCC2 2
                /// Settled to SNK on CC1
                SnkCC1 5
                /// Settled to SNK on CC2
                SnkCC2 6
                /// Audio accessory detected
                AudioAccessory 7
            }
            /// Last packet SOP'' Debug (true: yes).
            (bool)rxsop2db @2
            /// Last packet SOP' Debug (true: yes).
            (bool)rxsop1db @1
            /// Last packet SOP (true: yes).
            (bool)rxsop @0
        }
    }
    /// Interrupt Register A. Read to get status, write 1 to corresponding bit to clear.
    register Interrupta {
        address 62
        fields size_bits=8 {
            /// OCP or over-temp interrupt (true: occurred). Write 1 to clear this flag.
            (bool)i_ocp_temp @7
            /// Toggle done interrupt (true: occurred). Write 1 to clear this flag.
            (bool)i_togdone @6
            /// Soft reset fail interrupt (true: occurred). Write 1 to clear this flag.
            (bool)i_softfail @5
            /// Retry fail interrupt (true: occurred). Write 1 to clear this flag.
            (bool)i_retryfail @4
            /// Hard reset sent interrupt (true: occurred). Write 1 to clear this flag.
            (bool)i_hardsent @3
            /// Packet sent interrupt (true: occurred). Write 1 to clear this flag.
            (bool)i_txsent @2
            /// Soft reset received interrupt (true: occurred). Write 1 to clear this flag.
            (bool)i_softrst @1
            /// Hard reset received interrupt (true: occurred). Write 1 to clear this flag.
            (bool)i_hardrst @0
        }
    }
    /// Interrupt Register B. Read to get status, write 1 to corresponding bit to clear.
    register Interruptb {
        address 63
        fields size_bits=8 {
            /// GoodCRC sent interrupt (true: occurred). Write 1 to clear this flag.
            (bool)i_gcrcsent @0
        }
    }
    /// Status Register 0
    register Status0 {
        access RO
        address 64
        fields size_bits=8 {
            /// VBUS OK (true: VBUS valid).
            (bool)vbusok @7
            /// CC activity detected (true: active).
            (bool)activity @6
            /// Comparator result (true: CC > MDAC).
            (bool)comp @5
            /// CRC check valid (true: last packet CRC correct).
            (bool)crc_chk @4
            /// Alert condition (true: error occurred).
            (bool)alert @3
            /// Wake detected (true: device attempting attach).
            (bool)wake @2
            /// Current voltage status of the measured CC pin interpreted as host current levels.
            (uint:BcLvl)bc_lvl @1:0 {
                /// <200mV
                LessThan200mV 0
                /// >200mV, <660mV
                Between200And660mV 1
                /// >660mV, <1.23V
                Between660And1230mV 2
                /// >1.23V
                GreaterThan1230mV 3
            }
        }
    }
    /// Status Register 1
    register Status1 {
        access RO
        address 65
        fields size_bits=8 {
            /// Last packet SOP'' (true: yes).
            (bool)rxsop2 @7
            /// Last packet SOP' (true: yes).
            (bool)rxsop1 @6
            /// Receive FIFO empty (true: empty).
            (bool)rx_empty @5
            /// Receive FIFO full (true: full).
            (bool)rx_full @4
            /// Transmit FIFO empty (true: empty).
            (bool)tx_empty @3
            /// Transmit FIFO full (true: full).
            (bool)tx_full @2
            /// Over-temperature (true: too high).
            (bool)ovrtemp @1
            /// Over-current on VCONN (true: occurred).
            (bool)ocp @0
        }
    }
    /// Interrupt Status Register. Read to get status, write 1 to corresponding bit to clear.
    register Interrupt {
        address 66
        fields size_bits=8 {
            /// VBUSOK interrupt (true: VBUS transitioned). Write 1 to clear this flag.
            (bool)i_vbusok @7
            /// Activity interrupt (true: CC activity change). Write 1 to clear this flag.
            (bool)i_activity @6
            /// Comparator change interrupt (true: occurred). Write 1 to clear this flag.
            (bool)i_comp_chng @5
            /// CRC check interrupt (true: packet validated). Write 1 to clear this flag.
            (bool)i_crc_chk @4
            /// Alert interrupt (true: error condition). Write 1 to clear this flag.
            (bool)i_alert @3
            /// Wake interrupt (true: device attach attempt). Write 1 to clear this flag.
            (bool)i_wake @2
            /// Collision interrupt (true: transmit attempted during activity). Write 1 to clear this flag.
            (bool)i_collision @1
            /// BC_LVL interrupt (true: current level changed). Write 1 to clear this flag.
            (bool)i_bc_lvl @0
        }
    }
    /// FIFO buffer for USB PD communication (write to Tx, read from Rx).
    buffer Fifo {
        address 67
    }
}
