config:
  register_address_type: u8
  buffer_address_type: u8
  default_byte_order: BE
  defmt_feature: "defmt"

DeviceId:
  type: register
  address: 0x01
  size_bits: 8
  access: RO
  description: "Device Identification Register"
  fields:
    device_id:
      base: uint
      start: 0
      end: 8 # Bits 0-7
      description: "Device ID value (e.g., 0x9x for FUSB302B variants)."

Switches0:
  type: register
  address: 0x02
  size_bits: 8
  access: RW
  description: "Switch Control Register 0"
  fields:
    pu_en2:
      base: bool
      start: 7
      description: "Pull-up enable for CC2 (true: apply host pull-up current)."
    pu_en1:
      base: bool
      start: 6
      description: "Pull-up enable for CC1 (true: apply host pull-up current)."
    vconn_cc2:
      base: bool
      start: 5
      description: "VCONN enable for CC2 (true: turn on VCONN current)."
    vconn_cc1:
      base: bool
      start: 4
      description: "VCONN enable for CC1 (true: turn on VCONN current)."
    meas_cc2:
      base: bool
      start: 3
      description: "Measure CC2 (true: monitor/measure voltage on CC2)."
    meas_cc1:
      base: bool
      start: 2
      description: "Measure CC1 (true: monitor/measure voltage on CC1)."
    pdwn2:
      base: bool
      start: 1
      description: "Pull-down for CC2 (true: device pull-down on)."
    pdwn1:
      base: bool
      start: 0
      description: "Pull-down for CC1 (true: device pull-down on)."

Switches1:
  type: register
  address: 0x03
  size_bits: 8
  access: RW
  description: "Switch Control Register 1"
  fields:
    powerrole:
      base: bool
      start: 7
      description: "Power role for GoodCRC packet (true: Source, false: Sink for SOP)."
    specrev:
      base: uint
      start: 5 # Bits 5-6
      end: 7
      description: "Specification revision for GoodCRC packet."
      try_conversion:
        name: SpecRev
        Revision1_0: { value: 0, description: "Revision 1.0" }
        Revision2_0: { value: 1, description: "Revision 2.0" }
        # Datasheet indicates 0b10 and 0b11 are "Do Not Use"
    datarole:
      base: bool
      start: 4
      description: "Data role for GoodCRC packet (true: SRC, false: SNK for SOP)."
    # Bit 3 is Reserved in datasheet (Table 19)
    auto_crc:
      base: bool
      start: 2
      description: "Automatic CRC handling (true: auto-send GoodCRC on valid packet)."
    txcc2:
      base: bool
      start: 1
      description: "Transmit on CC2 (true: enable BMC transmit driver)."
    txcc1:
      base: bool
      start: 0
      description: "Transmit on CC1 (true: enable BMC transmit driver)."

Measure:
  type: register
  address: 0x04
  size_bits: 8
  access: RW
  description: "Measure Control Register"
  fields:
    # Bit 7 is Reserved in datasheet (Table 20)
    meas_vbus:
      base: bool
      start: 6
      description: "Measure VBUS (true: measure VBUS voltage)."
    mdac:
      base: uint
      start: 0 # Bits 0-5
      end: 6
      description: "MDAC setting for voltage measurement threshold."

Slice:
  type: register
  address: 0x05
  size_bits: 8
  access: RW
  description: "Slice Control Register"
  fields:
    sdac_hys:
      base: uint
      start: 6 # Bits 6-7
      end: 8
      description: "SDAC hysteresis setting."
      conversion:
        name: SdacHys
        NoHysteresis: { value: 0, description: "No hysteresis" } # 00
        Hys85mV: { value: 1, description: "85mV hysteresis" } # 01
        Hys170mV: { value: 2, description: "170mV hysteresis" } # 10
        Hys255mV: { value: 3, description: "255mV hysteresis" } # 11
    sdac:
      base: uint
      start: 0 # Bits 0-5
      end: 6
      description: "SDAC setting for BMC slicer DAC threshold."

Control0:
  type: register
  address: 0x06
  size_bits: 8
  access: RW # Register level access. Individual bits TX_FLUSH and TX_START are W/C (Write/Clear)
  description: "Control Register 0"
  fields:
    # Bit 7 is Reserved in datasheet (Table 22)
    tx_flush:
      base: bool
      start: 6
      description: "Flush transmit FIFO (true: self-clearing flush)."
      # To operate: Write 1 to flush. Bit clears automatically.
    int_mask:
      base: bool
      start: 5
      description: "Interrupt mask (true: mask all interrupts)."
    # Bit 4 is Reserved in datasheet (Table 22)
    host_cur:
      base: uint
      start: 2 # Bits 2-3
      end: 4
      description: "Host current setting for pull-ups."
      conversion:
        name: HostCurrent
        NoCurrent: { value: 0, description: "No current" } # 00
        Default80uA: { value: 1, description: "80µA - Default USB power" } # 01
        Medium180uA: { value: 2, description: "180µA - 1.5A" } # 10
        High330uA: { value: 3, description: "330µA - 3A" } # 11
    auto_pre:
      base: bool
      start: 1
      description: "Auto preamble (true: auto-start transmitter on good CRC)."
    tx_start:
      base: bool
      start: 0
      description: "Start transmission (true: initiate packet transmission)."
      # To operate: Write 1 to start. Bit clears automatically.
Control1:
  type: register
  address: 0x07
  size_bits: 8
  access: RW # Register level access. RX_FLUSH is W/C.
  description: "Control Register 1"
  fields:
    # Bit 7 is Reserved in datasheet (Table 23)
    ensop2db:
      base: bool
      start: 6
      description: "Enable SOP'' Debug packets (true: enabled)."
    ensop1db:
      base: bool
      start: 5
      description: "Enable SOP' Debug packets (true: enabled)."
    bist_mode2:
      base: bool
      start: 4
      description: "BIST Mode 01s pattern (true: enabled for testing)."
    # Bit 3 is Reserved in datasheet (Table 23)
    rx_flush:
      base: bool
      start: 2
      description: "Flush receive FIFO (true: self-clearing flush)."
      # To operate: Write 1 to flush. Bit clears automatically.
    ensop2:
      base: bool
      start: 1
      description: "Enable SOP'' packets (true: enabled)."
    ensop1:
      base: bool
      start: 0
      description: "Enable SOP' packets (true: enabled)."

Control2:
  type: register
  address: 0x08
  size_bits: 8
  access: RW
  description: "Control Register 2"
  fields:
    tog_save_pwr:
      base: uint
      start: 6 # Bits 6-7
      end: 8
      description: "Toggle save power setting."
      conversion:
        name: TogSavePwr
        NoDisable: { value: 0, description: "No disable state" } # 00
        Wait40ms: { value: 1, description: "Wait 40ms between cycles" } # 01
        Wait80ms: { value: 2, description: "Wait 80ms between cycles" } # 10
        Wait160ms: { value: 3, description: "Wait 160ms between cycles" } # 11
    tog_rd_only:
      base: bool
      start: 5
      description: "Toggle Rd only (true: stop on Rd only)."
    # Bit 4 is Reserved in datasheet (Table 24)
    wake_en:
      base: bool
      start: 3
      description: "Wake detection enable (true: enabled)."
    mode:
      base: uint
      start: 1 # Bits 1-2
      end: 3
      description: "Toggle mode selection."
      try_conversion:
        name: ToggleMode
        # Values from datasheet Table 24: 00=Do Not Use
        DrpPolling: { value: 1, description: "DRP polling" } # 01
        SnkPolling: { value: 2, description: "SNK polling" } # 10
        SrcPolling: { value: 3, description: "SRC polling" } # 11
    toggle:
      base: bool
      start: 0
      description: "Enable toggle (true: autonomous DRP/SNK/SRC toggle)."

Control3:
  type: register
  address: 0x09
  size_bits: 8
  access: RW # Register level access. SEND_HARD_RESET is W/C.
  description: "Control Register 3"
  fields:
    # Bit 7 is Reserved in datasheet (Table 25)
    send_hard_reset:
      base: bool
      start: 6
      description: "Send hard reset (true: initiate, self-clearing)."
      # To operate: Write 1 to send. Bit clears automatically.
    bist_tmode:
      base: bool
      start: 5
      description: "BIST test mode (true: clear RxFIFO after GoodCRC)."
    auto_hardreset:
      base: bool
      start: 4
      description: "Auto hard reset on soft reset fail (true: enabled)."
    auto_softreset:
      base: bool
      start: 3
      description: "Auto soft reset on retries fail (true: enabled)."
    n_retries:
      base: uint
      start: 1 # Bits 1-2
      end: 3
      description: "Number of packet retries."
      conversion:
        name: RetryCount
        NoRetries: { value: 0, description: "No retries" } # 00
        OneRetry: { value: 1, description: "1 retry" } # 01
        TwoRetries: { value: 2, description: "2 retries" } # 10
        ThreeRetries: { value: 3, description: "3 retries" } # 11
    auto_retry:
      base: bool
      start: 0
      description: "Auto retry on no GoodCRC (true: enabled)."

Mask:
  type: register
  address: 0x0A
  size_bits: 8
  access: RW
  description: "Interrupt Mask Register"
  fields:
    m_vbusok:
      base: bool
      start: 7
      description: "Mask I_VBUSOK interrupt (true: masked)."
    m_activity:
      base: bool
      start: 6
      description: "Mask I_ACTIVITY interrupt (true: masked)."
    m_comp_chng:
      base: bool
      start: 5
      description: "Mask I_COMP_CHNG interrupt (true: masked)."
    m_crc_chk:
      base: bool
      start: 4
      description: "Mask I_CRC_CHK interrupt (true: masked)."
    m_alert:
      base: bool
      start: 3
      description: "Mask I_ALERT interrupt (true: masked)."
    m_wake:
      base: bool
      start: 2
      description: "Mask I_WAKE interrupt (true: masked)."
    m_collision:
      base: bool
      start: 1
      description: "Mask I_COLLISION interrupt (true: masked)."
    m_bc_lvl:
      base: bool
      start: 0
      description: "Mask I_BC_LVL interrupt (true: masked)."
Power:
  type: register
  address: 0x0B
  size_bits: 8
  access: RW
  description: "Power Control Register"
  fields:
    # Bits 7-4 are Reserved in datasheet (Table 27)
    pwr3_internal_oscillator_enable: # PWR[3]
      base: bool
      start: 3
      description: "Enable internal oscillator."
    pwr2_measure_block_power_enable: # PWR[2]
      base: bool
      start: 2
      description: "Measure block powered."
    pwr1_receiver_and_measure_refs_enable: # PWR[1]
      base: bool
      start: 1
      description: "Receiver powered and current references for Measure block."
    pwr0_bandgap_and_wake_enable: # PWR[0]
      base: bool
      start: 0
      description: "Bandgap and wake circuit."

Reset:
  type: register
  address: 0x0C
  size_bits: 8
  access: WO # Datasheet indicates W/C (Write/Clear) for these bits. WO is appropriate.
  description: "Reset Control Register"
  fields:
    # Bits 7-2 are Reserved in datasheet (Table 28)
    pd_reset:
      base: bool
      start: 1
      description: "Reset PD logic (true: reset, self-clearing)."
      # To operate: Write 1 to reset. Bit clears automatically.
    sw_res:
      base: bool
      start: 0
      description: "Software reset (true: reset entire device, self-clearing)."
      # To operate: Write 1 to reset. Bit clears automatically.

Ocpreg:
  type: register
  address: 0x0D
  size_bits: 8
  access: RW
  description: "Over-Current Protection Register"
  fields:
    # Bits 7-4 are Reserved in datasheet (Table 29)
    ocp_range:
      base: bool
      start: 3
      description: "OCP range (true: 100-800mA, false: 10-80mA)."
    ocp_cur:
      base: uint
      start: 0 # Bits 0-2
      end: 3
      description: "OCP current setting (fraction of max range)."
      # Datasheet Table 29: 000 = max_range/8, ..., 111 = max_range
      # An enum could be created if specific named current levels are desired,
      # mapping them to the 0-7 values. For now, keeping as uint.

Maska:
  type: register
  address: 0x0E
  size_bits: 8
  access: RW
  description: "Interrupt Mask Register A"
  fields:
    m_ocp_temp:
      base: bool
      start: 7
      description: "Mask I_OCP_TEMP interrupt (true: masked)."
    m_togdone:
      base: bool
      start: 6
      description: "Mask I_TOGDONE interrupt (true: masked)."
    m_softfail:
      base: bool
      start: 5
      description: "Mask I_SOFTFAIL interrupt (true: masked)."
    m_retryfail:
      base: bool
      start: 4
      description: "Mask I_RETRYFAIL interrupt (true: masked)."
    m_hardsent:
      base: bool
      start: 3
      description: "Mask I_HARDSENT interrupt (true: masked)."
    m_txsent:
      base: bool
      start: 2
      description: "Mask I_TXSENT interrupt (true: masked)."
    m_softrst:
      base: bool
      start: 1
      description: "Mask I_SOFTRST interrupt (true: masked)."
    m_hardrst:
      base: bool
      start: 0
      description: "Mask I_HARDRST interrupt (true: masked)."

Maskb:
  type: register
  address: 0x0F
  size_bits: 8
  access: RW
  description: "Interrupt Mask Register B"
  fields:
    # Bits 7-1 are Reserved in datasheet (Table 31)
    m_gcrcsent:
      base: bool
      start: 0
      description: "Mask I_GCRCSENT interrupt (true: masked)."

Control4:
  type: register
  address: 0x10 # Address is 0x10h in device.txt, but datasheet Table 16 shows it at 0x00h then Table 32 shows 0x10h. Assuming 0x10 from device.txt is correct.
  size_bits: 8
  access: RW
  description: "Control Register 4"
  fields:
    # Bits 7-1 are Reserved in datasheet (Table 32)
    tog_exit_aud:
      base: bool
      start: 0
      description: "Toggle exit on audio accessory (true: stop on Ra both CC)."

Status0a:
  type: register
  address: 0x3C
  size_bits: 8
  access: RO # Datasheet Table 16 (PDF page 19) and Table 33 (PDF page 25) confirm RO.
  description: "Status Register 0A"
  fields:
    # Bits 7-6 are Reserved according to datasheet Table 33.
    softfail:
      base: bool
      start: 5
      description: "Soft reset retries failed (true: failed)."
    retryfail:
      base: bool
      start: 4
      description: "Packet retries failed (true: failed)."
    power: # Corresponds to POWER3, POWER2 in Table 33.
      base: uint
      start: 2 # Bits 2-3
      end: 4
      description: "Internal power state bits."
    softrst:
      base: bool
      start: 1
      description: "Soft reset packet received (true: received)."
    hardrst:
      base: bool
      start: 0
      description: "Hard reset received (true: received)."

Status1a:
  type: register
  address: 0x3D
  size_bits: 8
  access: RO # Datasheet Table 16 (PDF page 19) and Table 34 (PDF page 25) confirm RO.
  description: "Status Register 1A"
  fields:
    # Bits 7-6 are Reserved according to datasheet Table 34.
    togss: # Corresponds to TOGSS3, TOGSS2, TOGSS1 in Table 34.
      base: uint
      start: 3 # Bits 3-5
      end: 6
      description: "Toggle state status."
      try_conversion:
        name: ToggleState
        Running: { value: 0b000, description: "Toggle logic running" }
        SrcCC1: { value: 0b001, description: "Settled to SRC on CC1" }
        SrcCC2: { value: 0b010, description: "Settled to SRC on CC2" }
        # 0b011 "Not defined"
        # 0b100 "Not defined"
        SnkCC1: { value: 0b101, description: "Settled to SNK on CC1" }
        SnkCC2: { value: 0b110, description: "Settled to SNK on CC2" }
        AudioAccessory:
          { value: 0b111, description: "Audio accessory detected" }
    rxsop2db:
      base: bool
      start: 2
      description: "Last packet SOP'' Debug (true: yes)."
    rxsop1db:
      base: bool
      start: 1
      description: "Last packet SOP' Debug (true: yes)."
    rxsop:
      base: bool
      start: 0
      description: "Last packet SOP (true: yes)."

Interrupta:
  type: register
  address: 0x3E
  size_bits: 8
  access: RW # Datasheet Table 16 (PDF page 19) shows R/C (Read/Clear). RW is appropriate for YAML, clearing handled by writing 1 to bits.
  description: "Interrupt Register A (read/clear)"
  fields:
    i_ocp_temp:
      base: bool
      start: 7
      description: "OCP or over-temp interrupt (true: occurred)."
      # To clear: Write 1 to this bit.
    i_togdone:
      base: bool
      start: 6
      description: "Toggle done interrupt (true: occurred)."
      # To clear: Write 1 to this bit.
    i_softfail:
      base: bool
      start: 5
      description: "Soft reset fail interrupt (true: occurred)."
      # To clear: Write 1 to this bit.
    i_retryfail:
      base: bool
      start: 4
      description: "Retry fail interrupt (true: occurred)."
      # To clear: Write 1 to this bit.
    i_hardsent:
      base: bool
      start: 3
      description: "Hard reset sent interrupt (true: occurred)."
      # To clear: Write 1 to this bit.
    i_txsent:
      base: bool
      start: 2
      description: "Packet sent interrupt (true: occurred)."
      # To clear: Write 1 to this bit.
    i_softrst:
      base: bool
      start: 1
      description: "Soft reset received interrupt (true: occurred)."
      # To clear: Write 1 to this bit.
    i_hardrst:
      base: bool
      start: 0
      description: "Hard reset received interrupt (true: occurred)."
      # To clear: Write 1 to this bit.

Interruptb:
  type: register
  address: 0x3F
  size_bits: 8
  access: RW # Datasheet Table 16 (PDF page 19) shows R/C. RW is appropriate for YAML.
  description: "Interrupt Register B (read/clear)"
  fields:
    # Bits 7-1 are Reserved according to datasheet Table 36 (PDF page 26).
    i_gcrcsent:
      base: bool
      start: 0
      description: "GoodCRC sent interrupt (true: occurred)."
      # To clear: Write 1 to this bit.

Status0:
  type: register
  address: 0x40
  size_bits: 8
  access: RO # Datasheet Table 16 (PDF page 19) and Table 37 (PDF page 27) confirm RO.
  description: "Status Register 0"
  fields:
    vbusok:
      base: bool
      start: 7
      description: "VBUS OK (true: VBUS valid)."
    activity:
      base: bool
      start: 6
      description: "CC activity detected (true: active)."
    comp:
      base: bool
      start: 5
      description: "Comparator result (true: CC > MDAC)."
    crc_chk:
      base: bool
      start: 4
      description: "CRC check valid (true: last packet CRC correct)."
    alert:
      base: bool
      start: 3
      description: "Alert condition (true: error occurred)."
    wake:
      base: bool
      start: 2
      description: "Wake detected (true: device attempting attach)."
    bc_lvl:
      base: uint
      start: 0 # Bits 0-1
      end: 2
      description: "Battery charge level on CC." # Note: Datasheet Table 37 says "Current voltage status... interpreted as host current levels"
      conversion:
        name: BcLvl
        LessThan200mV: { value: 0b00, description: "<200mV" }
        Between200And660mV: { value: 0b01, description: ">200mV, <660mV" }
        Between660And1230mV: { value: 0b10, description: ">660mV, <1.23V" }
        GreaterThan1230mV: { value: 0b11, description: ">1.23V" }

Status1:
  type: register
  address: 0x41
  size_bits: 8
  access: RO # Datasheet Table 16 (PDF page 19) and Table 38 (PDF page 27) confirm RO.
  description: "Status Register 1"
  fields:
    rxsop2:
      base: bool
      start: 7
      description: "Last packet SOP'' (true: yes)."
    rxsop1:
      base: bool
      start: 6
      description: "Last packet SOP' (true: yes)."
    rx_empty:
      base: bool
      start: 5
      description: "Receive FIFO empty (true: empty)."
    rx_full:
      base: bool
      start: 4
      description: "Receive FIFO full (true: full)."
    tx_empty:
      base: bool
      start: 3
      description: "Transmit FIFO empty (true: empty)."
    tx_full:
      base: bool
      start: 2
      description: "Transmit FIFO full (true: full)."
    ovrtemp:
      base: bool
      start: 1
      description: "Over-temperature (true: too high)."
    ocp:
      base: bool
      start: 0
      description: "Over-current on VCONN (true: occurred)."

Interrupt: # This is the main interrupt register, often referred to as Interrupt Status Register
  type: register
  address: 0x42
  size_bits: 8
  access: RW # Datasheet Table 16 (PDF page 19) shows R/C (Read/Clear). RW is appropriate for YAML.
  description: "Interrupt Status Register (read/clear)"
  fields:
    i_vbusok:
      base: bool
      start: 7
      description: "VBUSOK interrupt (true: VBUS transitioned)."
      # To clear: Write 1 to this bit.
    i_activity:
      base: bool
      start: 6
      description: "Activity interrupt (true: CC activity change)."
      # To clear: Write 1 to this bit.
    i_comp_chng:
      base: bool
      start: 5
      description: "Comparator change interrupt (true: occurred)."
      # To clear: Write 1 to this bit.
    i_crc_chk:
      base: bool
      start: 4
      description: "CRC check interrupt (true: packet validated)."
      # To clear: Write 1 to this bit.
    i_alert:
      base: bool
      start: 3
      description: "Alert interrupt (true: error condition)."
      # To clear: Write 1 to this bit.
    i_wake:
      base: bool
      start: 2
      description: "Wake interrupt (true: device attach attempt)."
      # To clear: Write 1 to this bit.
    i_collision:
      base: bool
      start: 1
      description: "Collision interrupt (true: transmit attempted during activity)."
      # To clear: Write 1 to this bit.
    i_bc_lvl:
      base: bool
      start: 0
      description: "BC_LVL interrupt (true: current level changed)."
      # To clear: Write 1 to this bit.

Fifo:
  type: buffer
  address: 0x43 # Datasheet Table 16 (PDF page 19) and Table 40 (PDF page 28) confirm address.
  access: RW # FIFO can be written to (Tx) and read from (Rx).
  description: "FIFO buffer for USB PD communication (write to Tx, read from Rx)."
  # The datasheet (Table 40) describes TX/RX Token as 8 bits, Read or Write.
  # The device-driver toolkit typically doesn't define fields for buffers,
  # as they are treated as byte streams. The size is implicitly 1 byte per R/W op
  # at this address, but the physical FIFO has depth (Tx 48 bytes, Rx 80 bytes as per page 11 of datasheet).
  # The YAML defines the access point, not the entire FIFO structure.
